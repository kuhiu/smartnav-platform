#-------------------------------------------------------#
#                start of color plugin                  #
#-------------------------------------------------------#

# Set colorful PS1 only on colorful terminals.
# dircolors --print-database uses its own built-in database
# instead of using /etc/DIR_COLORS.  Try to use the external file
# first to take advantage of user additions.
use_color=false
if type -P dircolors >/dev/null ; then
    # Enable colors for ls, etc.  Prefer ~/.dir_colors #64489
    LS_COLORS=
    if [[ -f ~/.dir_colors ]] ; then
        # If you have a custom file, chances are high that it's not the default.
        used_default_dircolors="no"
        eval "$(dircolors -b ~/.dir_colors)"
    elif [[ -f /etc/DIR_COLORS ]] ; then
        # People might have customized the system database.
        used_default_dircolors="maybe"
        eval "$(dircolors -b /etc/DIR_COLORS)"
    else
        used_default_dircolors="yes"
        eval "$(dircolors -b)"
    fi
    if [[ -n ${LS_COLORS:+set} ]] ; then
        use_color=true
    fi
    unset used_default_dircolors
else
    # Some systems (e.g. BSD & embedded) don't typically come with
    # dircolors so we need to hardcode some terminals in here.
    case ${TERM} in
    [aEkx]term*|rxvt*|gnome*|konsole*|screen|cons25|*color) use_color=true;;
    esac
fi

if ${use_color} ; then
    if [[ ${EUID} == 0 ]] ; then
        PS1='\[\033[01;31m\]\h\[\033[01;34m\] \W \$\[\033[00m\] '
    else
        PS1='\[\033[01;32m\]\u@\h\[\033[01;34m\] \w \$\[\033[00m\] '
    fi

    alias ls='ls --color=auto'
    alias grep='grep --colour=auto'
    alias egrep='egrep --colour=auto'
    alias fgrep='fgrep --colour=auto'
else
    if [[ ${EUID} == 0 ]] ; then
        # show root@ when we don't have colors
        PS1='\u@\h \W \$ '
    else
        PS1='\u@\h \w \$ '
    fi
fi

for sh in /etc/bash/bashrc.d/* ; do
    [[ -r ${sh} ]] && source "${sh}"
done

# Try to keep environment pollution down, EPA loves us.
unset use_color sh

#-------------------------------------------------------#
#                  end of color plugin                  #
#-------------------------------------------------------#

###############################################################################
# Глобальные переменные устанавилвающие цвет и стиль шрифта в выодимых
# сообщениях
###############################################################################
# отключить все модификаторы
ALL_OFF="\e[1;0m"
# применить "жирный" стиль
BOLD="\e[1;1m"
# установить "красный жирный"
BRED="${BOLD}\e[1;31m"
# установить "зеленый жирный"
BGREEN="${BOLD}\e[1;32m"
# установить "синий жирный"
BBLUE="${BOLD}\e[1;34m"
# установить "фиолетовый жирный"
BVIOLET="${BOLD}\e[1;35m"

###############################################################################
# @brief Функция вывода сообщения об ошибке
###############################################################################
function err() {
    local mesg=$1; shift
    printf "${BRED}==>${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

###############################################################################
# @brief Функция вывода сообщения об успешном выполнении/info сообщения
###############################################################################
function msg() {
    local mesg=$1; shift
    printf "${BGREEN}==>${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

###############################################################################
# @brief Функция вывода сообщения с предупреждением
###############################################################################
function warn() {
    local mesg=$1; shift
    printf "${BBLUE}  ->${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

###############################################################################
# @brief Функция опроса
###############################################################################
function qst() {
    local mesg=$1; shift
    answ=0
    while [[ 1 ]]; do
        printf "${BGREEN}::${ALL_OFF}${BOLD} ${mesg} ${ALL_OFF}${BOLD}[N${ALL_OFF}/y]? " "$@" >&2
        read tmp
        case $tmp in
            Y|y)
                return 1
                ;;
            N|n|"" )
                msg "пропускаю..."
                return 0
                ;;
              * )
                err "Некорректный ввод"
        esac
    done
}

###############################################################################
# @brief Проверить инициализированы ли переменные окружения SDK
#
# @retval true - если да, наче false
###############################################################################
function sdk_env_is_ready ()
{
    # проверим есть ли в известных путях паттерн встречающийся в sdk путях
    echo $PATH | grep "sdk/sysroot" > /dev/null

    if [[ $? == 0 ]]; then
        return 1
    else
        return 0
    fi
}

###############################################################################
# @brief Функция проверки на наличие путей SDK перез запуском программ Petalinux
# 
# Функция проверяет существуют ли пути SDK в переменных окружения, и если да -
# спрашивает у пользователя запускать ли низлежащюю программу Petalinux. Сама
# программа Petalinux передается как первый аргумент
###############################################################################
function pl_check_sdk_path ()
    {
    sdk_env_is_ready
    if [[ $? == 0 ]]; then
        $@
    else
        err "Ошибка! В переменных окружения обнаружены пути из состава SDK. \
Возможна некорректная работа."
        qst "Продолжить?"
        ret=$?
        if [[ $ret == 0 ]]; then
            return 1
        fi
        $@
    fi
}

function plbuild ()
{
    pl_check_sdk_path petalinux-build $@
}

function plcreate ()
{
    pl_check_sdk_path petalinux-create $@
}

function plconfig ()
{
    pl_check_sdk_path petalinux-config $@
}
